module test_integrate
    use potential_type, only: Potential_t, Harmonic_Potential_t
    use integrate, only: numerov_thijssen
    use precision, only: rp
    use constants, only: pi
    use funit
    implicit none

    ! note: you must go to Testing/Temporary/LastTest.log to get useful output
    ! or do ctest --output-on-failure

    ! maybe make a tolerance parameter here based on rp

 contains

    ! The following procedure will be called before running
   ! each test in the suite.
 @before
 subroutine set_up()
    ! type(Harmonic_Potential_t) :: hpot
 end subroutine set_up

 ! The following procedure will be called after running
 ! each test in the suite.
 @after
 subroutine tear_down()
    ! integer :: unit
    ! logical :: exists

    ! inquire(file='test.txt', number=unit, exist=exists)
    ! if (unit /= -1) then
    !    close(unit, status='delete')
    ! elseif (exists) then
    !    open(newunit=unit, file='test.txt')
    !    close(unit, status='delete')
    ! end if

 end subroutine tear_down

    !!! Note: no test annotation !!!
    subroutine not_a_test()
       print*,'this procedure should not be called'
    end subroutine not_a_test


    @test
    subroutine test_assert_true_and_false()
       @assertTrue(1 == 1)
       @assertFalse(1 == 2)
    end subroutine test_assert_true_and_false

    ! ! @test ! TODO
    ! TODO this doesn't compile with REAL=64 for some reason...
    ! subroutine test_numerov_harmonic()
    !     ! TODO check tolerances (don't remember how)
    !     !! check 1 of page 20 in Thijssen
    !     !! for V(r)=r^2, l=0, E=3 should (apparently) give
    !     !! r * exp(-r^2/2) * exp(h^2/2)
    !     ! wavelength = 2*pi*hbar/sqrt(2*m*E)
    !     ! want r1 and r2 to differ by ~wavelength/2
    !     ! r1 to be the first integration point past rmax
    !     ! hbar^2/2m=1 -> hbar*w=2
    !     ! w = 2*pi/wavelength
    !     ! wavelength/2 = pi*hbar/sqrt(2*m*E)
    !     !              = pi*sqrt(hbar^2/(2*m))/sqrt(E)
    !     !              = pi/sqrt(E)
    !     ! or, in this case,
    !     !              = pi/sqrt(3)
    !     !              ~ 1.813799
    !     real(rp) :: rmax = 5.0_rp ! this is what Thijssen uses I think
    !     type(Harmonic_Potential_t) :: pot
    !     integer :: l = 0
    !     real(rp) :: h ! integration step
    !     real(rp) :: x = 3._rp ! energy
    !     real(rp) :: r1, r2, ulr1, ulr2, tmp

    !     ! integration step divides into rmax, so r1=rmax
    !     h = 0.01_rp
    !     call numerov(pot, h, l, x, rmax, r1, r2, ulr1, ulr2)
    !     @assertEqual(r1, rmax, tolerance=1.e-10_rp, message='r1 should be rmax if rmax divisible by h')

    !     ! @assertEqual(r2, 6.0_rp, tolerance=1.e-10_rp)
    !     print*, ulr1, ulr2 ! , harmonic_sol(r1,h)
    !     ! tmp = harmonic_sol(r1,h)
    !     ! tmp =  r1 * exp(-r1*r1/2) * exp(h*h/2)
    !     tmp =  r1 * exp((h*h-r1*r1)/2._rp) ! * exp(h*h/2)
    !     print*, tmp
    !     print*, exp(-r1*r1/2)
    !     print*, exp(h*h/2)
    !     ! tmp = ulr1 ! TODO problem is definitely in tmp
    !     ! ulr1=tmp ! actually maybe a type mismatch??
    !     print*, ulr1-tmp
    !     ! TODO looks like pFUnit just gives up and crahes when there is too
    !     ! great a magnitude difference for some reason -_-
    !     ! unless the tolerance is huge
    !     ! ulr1=-2.88930874013103365092862443614908972_rp
    !     ! tmp=1.90096827998481017860294953523121622*1.e-5
        
    !     @assertEqual(ulr1, tmp, tolerance=1.e-5_rp)
    !     ! @assertEqual(ulr2, harmonic_sol(r2,h), tolerance=1.e-10)
    ! end subroutine test_numerov_harmonic

    @test
    subroutine test_numerov_thijssen()
        real(rp) :: hstep = 0.02, energy=1.5, maxDist=5.0
        integer :: secMaxI, maxI
        integer, parameter :: maxSol=60000 ! seems a tad high?? use allocatable arrays
        real(rp) :: r(maxSol), FArr(maxSol), phi1, phi2, solution(maxSol)
        real(rp) :: K
        real(rp) :: quartWave, secR
        real(rp) :: start = 0
        integer :: i
        real(rp) :: phiend1, phiend2, rcurr
        real(rp) :: A, tmp
        maxI = nint((maxDist-start)/hstep)
        K = sqrt(energy)
        quartWave = 0.5D0*PI/K
        secR = maxDist + quartWave
        secMaxI = int((secR-start)/hstep)
        ! implied loop
        ! r(1) = 0
        r = [((i-1)*hstep, i=1, secMaxI+1)]
        ! FArr = [(harmonicF(start+(i-1)*hstep, energy), i=1, secMaxI)]
        FArr = harmonicF(r, energy)
        ! print*, r(1:secMaxI)
        ! print*, FArr(1:secMaxI)
        phi1 = 0 ! how could this possibly be the value at r=0?? n=1 I guess
        phi2 = hstep
        call numerov_thijssen(hstep, 1, secMaxI+1, maxSol, FArr, .false., phi1, phi2, solution)
        phiend1 = solution(maxI+1)
        print*, 'rmax?', r(maxI+1)
        print*, 'phiend1', phiend1
        rcurr = r(maxI+1)
        phiend2 = solution(secMaxI+1)
        A = 1._rp/sqrt(2._rp)/pi**(1/4._rp)
        tmp =A * exp((-rcurr*rcurr)/2._rp)
        ! why does the exact solution depend on the integration step?! Typo?
        ! @assertEqual(phiend1,rcurr * exp((hstep*hstep-rcurr*rcurr)/2._rp), tolerance=1.e-5_rp)
        @assertEqual(phiend1, tmp, tolerance=1.e-5_rp)
    end subroutine test_numerov_thijssen

    ! pure real(rp) function harmonic_sol(r,h) result(retval)
    ! real(rp), intent(in) :: r,h
    ! retval = r * exp(-r*r/2) * exp(h*h/2)
    ! end function harmonic_sol
    pure elemental real(rp) function harmonicF(r, energy) result(V_eff)
        implicit none
        !! returns the RHS of the radial Schroedinger equation, called F in
        !! equation 2.10 in Thijssen
        !! note this is actually 2*m/hbar^2 * F but at least for now the prefactor
        !! is unity
        ! class(Potential_t), intent(in) :: pot
        ! integer, intent(in) :: l ! assume = 0
        ! no alpha, assume harmonic
        real(rp), intent(in) :: r, energy

        ! V_eff = 2*r*r - energy
        V_eff = r*r-energy*2.

    end function harmonicF
 end module test_integrate
